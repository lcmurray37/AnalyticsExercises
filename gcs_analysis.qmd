---
title: "Ground Combat Systems (GCS) Analysis"
format: html
editor: visual
---

# Objective

## Programs of Interest

Illuminate what the potential client Department spent on the following major Ground Combat Systems (GCS) programs:

-   Abrams tank (e.g., M1A1)
-   Bradley fighting vehicle (e.g., M2A1)
-   Stryker armored personnel carrier (e.g., M1130)

## Analysis Requirements

Produce an analysis of FY16 through FY20 federal contract data for these programs:

-   Summarize prominent vendors, funding/contracting offices, and agencies
-   Outline key technologies, products, and services acquired
-   Increase understanding of what future acquisitions for each of these programs may look like given:
    -   Where they are in their life cycles
    -   What potential risks may be associated with the management of the programs

## Analysis Structure

1)  Solutions to the following pain points the potential client has previously encountered in their data, including:

-   Vendor name normalization
-   Misidentified or unidentified GCS contracts and vendors

2)  Assessment of the following:

-   Spending trends
-   Key technologies
-   Programs
-   Vendors
-   Any other elements interesting about the market (e.g., current acquisition life cycle status of the GCS programs and what it means for future investments; or past/future federal budget alignment within each program).

3)  Assessment should include:

-   Conclusion with key takeaways
-   Conclusion with 1-2 interesting insights that potential client can use to inform their acquisition decisions

4)  Commented-code or a short summary of methodology used to clean/normalize, organize, and/or transform the data.

# Initialize Project

## Load packages & functions

```{r}
# packages for data manipulation
library(dplyr)
library(openxlsx2)
library(purrr)
library(stringr)
library(stringdist)

# packages required to access usaspending api
library(httr2)
library(jsonlite)

# source anonymous functions
source(paste0(getwd(), "/functions/clean.R"))
```

## Set parameters

```{r}
dir_path <- paste0("/Users/", Sys.info()["user"], "/R/DATA/")
file_name <- "ground_vehicles.xlsx"
data_location <- file.path(dir_path, file_name)
```

## Read data

```{r}
ground_vehicles <- read_xlsx(data_location)
View(ground_vehicles)
```

# Clean data

## Identify cons of interest

```{r}
# filter dataframe based on ground combat systems program portfolio
## use toupper since data appears to be ALL CAPS
keywords <- toupper(c("Abrams tank", "M1-A1", "M-1 Abrams", "Abrams", "M1 Abrams",
              "Bradley fighting vehicle", "Bradley", "BVF", "M2-A1", "M2A1", "M2",
              "Stryker armored personnel carrier", "M1130", "M1255 CVV", "M1130 Commander Vehicle", "M1130 CV"))
gcs_portfolio <- ground_vehicles %>% 
  filter(str_detect(toupper(Title), pattern = paste(keywords, collapse = '|')))
```

# USASpending for Additional Data

## Background

The USASpending API (Application Programming Interface) allows the public to access comprehensive U.S. government spending data ([read more](https://api.usaspending.gov/)). This example shows how to access this API utilizing the `httr2` package.

There are limits to the external server's ability to handle requests, thus a final solution would be implementing a full data pipeline to leverage all relevant USASpending information. This can be done through several ways, including:

-   Creating an external storage and server host of a copy of the database for faster calls
-   Customizing API calls with more efficient querying

## Identify Contract/DOs

```{r}
unique_ids <- gcs_portfolio %>% 
  select("contractnumber" = 2, "deliveryorder" = 3) %>% 
  mutate(across(everything(), ~ remove_non_alphanumeric(.x))) %>% 
  unique()
```

## Convert list to API call format

```{r}
# use ananymous function 
combined_list <- format_contract_numbers(unique_ids)
combined_list <- lapply(combined_list, na.omit)

# convert list to vectors
contract_num_formatted <- combined_list[1] %>% 
  unlist() %>% 
  unique()

contract_num_do_formatted <- combined_list[2] %>% 
  unlist() %>% 
  unique()

## splice list, if time-out error
#do_segments <- split_segments(lst = contract_num_do_formatted, segments = 0.2)
```

## Grab Contract data without DOs

```{r}
# initialize list
final_con_list <- list()
```

```{r}
final_con_list$con <- transactions_request(combined_list$contract_num_formatted)
```

```{r}
final_con_list$do  <- transactions_request(combined_list$contract_num_do_formatted)
```

```{r}
usa_spending_df <- extract_results(final_con_list)
```

